âš™ğŸ’¾ğŸ—ƒâ˜
ğŸ’¾ Part 1
ğŸ’» What is a System?

    ğŸ“¢ Architecture of collection of technologies or softwares that are connected to each other to serve the certain set of users  to fulfill certain set of requirements

    ğŸ“¢ Factors
    âœ” Components chosen to serve
    âœ” Set of Users
    âœ” Set of requirements

ğŸ’» What is design?
    ğŸ“¢ How everything is intertwined, the process
    âœ” design of a static website will be different from the live streaming websites


ğŸ’» Why System Design?
    ğŸ“¢ Skills that consists of everything
    âœ” Need to know what are the components to be used, why & where to be used
    âœ” Point out constraints & pain points
    âœ” Figure out pros and cons

ğŸ’¾ Part 2
ğŸ’» Components of System Design
    ğŸ“¢ Basic building blocks of system design

    Types of components
    ğŸ“¢ Logical Entities: 
    âœ” Data
    âœ” Databases
    âœ” Applications
    âœ” Cache 
    âœ” Message queues
    âœ” Infrastructure
    âœ” Communication

    âœ” DatabasesğŸ–¥ <=> ApplicationsğŸ’» <=> UsersğŸ‘¨
    âœ” communication protocol like TCP/HTTP/IP, etc helps communicate & interact between machines where databases and applications are running
    âœ” Presentation layer can be all the views in mobile app or web app
    âœ” not all applications might need presentation layer
    âœ” the components can be run on the cloud services like aws, azure, etc.


    ğŸ“¢ Tangible Entities [technologies]
    âœ” Store text, images, videos ...
      MongoDB, MySQL, Cassandra ...
    âœ” Java, Golang, Python, Amber, React, Angular ...
    âœ” Redis, MemeCache ...
    âœ” Kafka, RabbitMQ ...
    âœ” AWS, Google Cloud Platform, Azure ...
    âœ” APIs, RPCs, Messages ...

     Presentation Layer ğŸ’» <=> ApplicationsğŸ’» <=> DatabasesğŸ–¥ 

ğŸ’¾ Part 3
ğŸ’» Client Server Architecture
    ğŸ“¢ Two-tier architecture
    âœ” clientğŸ’» <=> Server ğŸ–¥
    âœ” Logic and data either sits on client or Server

    ğŸ“¢ three-tier architecture
    âœ” clientğŸ’» <=> LogicğŸ–¥ <=> Data ğŸ–¥
    âœ” Logic and data is separated => Application & Database layer

    ğŸ“¢ N-tier architecture
    âœ” clientğŸ’»<=> Load balancer <=> LogicğŸ–¥<=> Caching <=> Data ğŸ–¥
    âœ” Logic and data is separated => Application & Database layer

    ğŸ“¢How to select the architecture?
    âœ” Thin clients =>  Majority of processing happens in the backend
                    Example: E commerce sites, streaming applications
    âœ” Thick clients => Majority of processing happens in the frontend
                    Example: Gaming Apps, Video editing software
    âœ” 2tier example => light weight website for small business
    âœ” 3tier example => Basic library mgmt for school
    âœ” N tier example => large scale systems(Gmail, Facebook)

ğŸ’¾ Part 4     
ğŸ’» Proxies 
    ğŸ“¢ On behalf
    âœ” used for security

     ğŸ“¢ Forward Proxies 
     âœ” clientğŸ’» <=> Forward Proxies <=> | ServerğŸ–¥
     âœ” AKA Client side proxy 
     âœ” Anonymity of client
     âœ” disguises a clients IP addresses
     âœ” block malicious traffic from reaching an origin web Server
     âœ” improve user's experience by caching external site content

    ğŸ“¢ Reverse Proxies 
     âœ” clientğŸ’» <=> | Reverse Proxies <=>  ServerğŸ–¥/ServerğŸ–¥/ServerğŸ–¥
     âœ” AKA Server side proxy 
     âœ” Anonymity of servers
     âœ” disguises a servers IP addresses
     âœ” used for traffic control caching the response from servers
     âœ” Load balancing => distributes the load for app using multiple servers
     âœ” Provides a single configuration point to manage SSL/technologies
     âœ” Mitigate the DDoS attacks=> deflates overall impact of distributed denial of services attacks.
     âœ” Example: VPN, Dark web
     âœ” Can be use to bypass the blocked websites
     âœ” Sometimes bottleneck problem might occur

ğŸ’¾ Part 5
ğŸ’» Data & Data Flow
    ğŸ“¢ Data    
    ğŸ“¢ Data format/representation    
    ğŸ“¢ Mechanisms for Data flow    
    ğŸ“¢ Factors => Type, volume, scale, purpose    

    ğŸ“¢ Layers
       âœ” Business Layer => text, images, vides, notes ... 
       âœ” Application Layer => JSON/XML
       âœ” Data stores => databases- tables, indexes, lists, trees
       âœ” Network Layer => Packets  
       âœ” Hardware Layer => 0's & 1's

"Always think about data flow"

    ğŸ“¢ Data storesğŸ–¥
      âœ” Databases => Username, phone ...
      âœ” Queues => [Send sms request, send email request]
      âœ” Caches => [Request:Response] 
      âœ” Indexes => [Most searched items, items searched in last 1 hour]

    ğŸ“¢ Data flow methods <=>
      âœ” APIs  
      âœ” Messages  
      âœ” Events  

    ğŸ“¢ Data generation 
      âœ” Users => Input
      âœ” Internal => system populated 
      âœ” Insights => when user upload or retrieve some data 
        Example: if a user buys, invoice generation
                youtube history, payment details, profile details,...

    ğŸ“¢ Factors
      âœ” Type of data => knowing the type of data is important, images or videos ...  
      âœ” Volume  => system supporting gb or tb
      âœ” Consumption / Retrieval => reads /writes
      âœ” security => transaction, banking

    ğŸ“¢ Types of system
    Examples
      âœ” Authorization system => User login, ID management
      âœ” Streaming system => Netflix, Hotstar, Prime video, ...
      âœ” Transactional system => Ecommerce, booking rides, grocery, ...
      âœ” Heavy compute system => image recognition, video processing, using ML models

ğŸ’¾ Part 6
ğŸ’» Databases
    ğŸ“¢ Types of Databases    
    ğŸ“¢ Pros & Cons 
    ğŸ“¢ Use Cases   
    ğŸ“¢ Examples

    ğŸ“¢ Types of Databases   
      âœ” Relational
        - Schema => Tables & Rows
                => Primary key, not null, foreign key, int, varchar, default, etc. are all example of schema constraints
            Example:
            Table1: Employees => ID[Primary key], Name, age,dept_id[Foreign key,NOT NULL],acc_id [Foreign key, NOT NULL] 
            Table1: Department => ID[Primary key], Name, start_date, HOD
            Table1: Account => ID[Primary key], debit, credit, balance, is_employee
        => database for inter related complex data can be easily designed
        => ensures garbage or null value is not populated
        => ensures all other schema constraints are followed

        - ACID Properties => 
            => Atomicity: Either All or none
            => Consistency: Same value for both the request
            => Isolation: Read and writes are isolated
            => Durability: Mechanism to guarantee that transactions completed will survive permanently

        - Schema change is difficult to evolve
        - difficult for horizontal scaling

      âœ” Non-relational => AKA NoSQL Databases
      - No fixed schemas
      - Does not follow ACID Properties
      - different types of relational databases are used for different purposes

      âœ” Key value stores => Application or configuration data
                        => caching data
            example: feature, discount, enable cities,...

      âœ” Document based Databases
      - No fixed schema, supports heavy reads and writes
      - collections(tables) => documents(rows)
      - flexible complex dynamic data
      - highly scalable
      - sharding
      - special query operations/aggregations
      - saved in JSON format
        example: 
        [
            {
                id:"1",
                name: "jack",
                city: 
                {
                    id:"2",
                    name:"la",
                    state:"california"
                },
                country:
                {
                    id:"4",
                    Name:"usa",
                    code:"US",
                    continent:"North America"
                }
            }

        ]

      âœ” column based Databases
      - supports large number of heavy writes, special reads
      - distributed
      - Example: event data, or streaming data, storing data for songs
            Cassandra, HBase, Sylla
     
      âœ” Search Databases
      - Supports Full text search queries
      - Images/Videos, Amazon s3, buckets
      - Large datasets
      - Time series
      - Example: Elastic, Solar, ...

ğŸ’¾ Part 7
ğŸ“¢ Anatomy of Applications & services
ğŸ’» Client <=> ğŸ’» Servers
  âœ” Application in both client and server side have different responsibilities
  Tech stack
  âœ” The applications are language agnostic for interacting with each other

  Client Apps => rendering UI elements
              => handle interactions
              => collect data
              => communicate with backend via APIs to fetch/store data
              => render static data/info
  Server Apps => Expose API endpoints
              => house business Logic
              => handling data modeling/transform
              => interact with data stores
              => interact with other services           
ğŸ’» Elements/factors of app design/development
              => requirements - gather requirements
              => layer - web/mobile/desktop/backend app
              => tech stack - which language to use
              => code structures / design pattern
              => data store interactions
              => performance cost
              => deployment
              => monitoring
              => operations excellence /reliability

ğŸ’¾ Part 8
ğŸ’» Application Programming Interface (API)
ğŸ“¢ What is API?
    âœ” one piece of code interacting with another which can run on different machine.
    âœ” Advantages => communication 
                => Abstraction
                => platform agnostic

ğŸ“¢ Examples and usecases
ğŸ“¢ Types of APIs

    âœ” Private APIs => hidden APIs
    âœ” Public APIs => available for Public,
    âœ” web APIs => superset of private & public, get,post...
    âœ” SDK/library => lock,fork, join, release lock

ğŸ“¢ API Factors => API contracts
                => Documentation
                => Data format
                => security

ğŸ“¢ API Standards => RPC
                => SOAP
                => REST

ğŸ’¾ Part 9 
ğŸ’» Cache
  ğŸ“¢ What is Cache?
      âœ” a hardware or a software component which helps in serving the data which is frequently requested or expensive to compute on, so cache saves this request.
      âœ” cache example => server side cache (reverse proxy)
              => browser cache (client side)
              => similar redundant request and response is saved in cache memory

  ğŸ“¢ invalidation and eviction  
     âœ” Cache invalidation => data should be changed in some time, updating old value with a new value in cache is cache invalidation
         => TTL - Time to live (expiry date for the cache)
     âœ” Cache eviction - when old cache has to be evicted for new keys
                      => FIFO - first in first out (first inserted is evicted)
                      => LRU - Least recently used (oldest is evicted)
                      => LFU - Least frequently used (less times used evicted)
  
  ğŸ“¢ Cache pattern
    âœ” Cache aside strategy/Patterns -application communication with cache doesnot communicate with Database
                      => Advantage - when cache fails, application can still serve using database
                      => supports heavy reads
                      => works even if cache is down
                      => TTL/application code have to be used keep DB and cache consistent

                      => disadvantage - to decide about cache long expiry or application code to refresh cache


    âœ” Cache read through strategy/pattern - cache sits between application & database
                                           - application only communicates with cache
                       => Advantage - read heavy work 
                       => great alternate for read heavy workloads, example: newsfeed
                       => data modeling of cache and db has to be smaller
      
                        => disadvantage - first request always miss cache. (can be solved by preloading the cache)
  
    âœ” Cache write through strategy/pattern - similar to read through, application will read & write in cache.           => Advantage - can directly write to cache
                        => disadvantage - extra layer of latency of reading from cache (can be solved using write around pattern)
    
    âœ” Cache write around strategy/pattern- writes directly to db but reads from cache

    âœ” Cache write back strategy/pattern- writes is saved in cache and writing in db later in bulk
                        => Advantage - useful for write heavy workloads
                                    - db failure can be sustained for the time cache keeps data in bulk
                                    - used by various DB's internal implementation
                                    - cache failure results in system failure

  ğŸ“¢ Where is my cache?
      => can be in client browser
      => can be in forward proxy
      => can be in reverse proxy
      => can be in application code
      => can be outside database