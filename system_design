âš™ğŸ’¾ğŸ—ƒâ˜
ğŸ’¾ Part 1
ğŸ’» What is a System?

    ğŸ“¢ Architecture of collection of technologies or softwares that are connected
     to each other to serve the certain set of users  to fulfill certain set of requirements

    ğŸ“¢ Factors
    âœ” Components chosen to serve
    âœ” Set of Users
    âœ” Set of requirements

ğŸ’» What is design?
    ğŸ“¢ How everything is intertwined, the process
    âœ” design of a static website will be different from the live streaming websites


ğŸ’» Why System Design?
    ğŸ“¢ Skills that consists of everything
    âœ” Need to know what are the components to be used, why & where to be used
    âœ” Point out constraints & pain points
    âœ” Figure out pros and cons

ğŸ’¾ Part 2
ğŸ’» Components of System Design
    ğŸ“¢ Basic building blocks of system design

    Types of components
    ğŸ“¢ Logical Entities: 
    âœ” Data
    âœ” Databases
    âœ” Applications
    âœ” Cache 
    âœ” Message queues
    âœ” Infrastructure
    âœ” Communication

    âœ” DatabasesğŸ–¥ <=> ApplicationsğŸ’» <=> UsersğŸ‘¨
    âœ” communication protocol like TCP/HTTP/IP, etc helps communicate & interact
    between machines where databases and applications are running
    âœ” Presentation layer can be all the views in mobile app or web app
    âœ” not all applications might need presentation layer
    âœ” the components can be run on the cloud services like aws, azure, etc.


    ğŸ“¢ Tangible Entities [technologies]
    âœ” Store text, images, videos ...
      MongoDB, MySQL, Cassandra ...
    âœ” Java, Golang, Python, Amber, React, Angular ...
    âœ” Redis, MemeCache ...
    âœ” Kafka, RabbitMQ ...
    âœ” AWS, Google Cloud Platform, Azure ...
    âœ” APIs, RPCs, Messages ...

     Presentation Layer ğŸ’» <=> ApplicationsğŸ’» <=> DatabasesğŸ–¥ 

ğŸ’¾ Part 3
ğŸ’» Client Server Architecture
    ğŸ“¢ Two-tier architecture
    âœ” clientğŸ’» <=> Server ğŸ–¥
    âœ” Logic and data either sits on client or Server

    ğŸ“¢ three-tier architecture
    âœ” clientğŸ’» <=> LogicğŸ–¥ <=> Data ğŸ–¥
    âœ” Logic and data is separated => Application & Database layer

    ğŸ“¢ N-tier architecture
    âœ” clientğŸ’»<=> Load balancer <=> LogicğŸ–¥<=> Caching <=> Data ğŸ–¥
    âœ” Logic and data is separated => Application & Database layer

    ğŸ“¢How to select the architecture?
    âœ” Thin clients =>  Majority of processing happens in the backend
                    Example: E commerce sites, streaming applications
    âœ” Thick clients => Majority of processing happens in the frontend
                    Example: Gaming Apps, Video editing software
    âœ” 2tier example => light weight website for small business
    âœ” 3tier example => Basic library mgmt for school
    âœ” N tier example => large scale systems(Gmail, Facebook)

ğŸ’¾ Part 4     
ğŸ’» Proxies 
    ğŸ“¢ On behalf
    âœ” used for security

     ğŸ“¢ Forward Proxies 
     âœ” clientğŸ’» <=> Forward Proxies <=> | ServerğŸ–¥
     âœ” AKA Client side proxy 
     âœ” Anonymity of client
     âœ” disguises a clients IP addresses
     âœ” block malicious traffic from reaching an origin web Server
     âœ” improve user's experience by caching external site content

    ğŸ“¢ Reverse Proxies 
     âœ” clientğŸ’» <=> | Reverse Proxies <=>  ServerğŸ–¥
     âœ” AKA Server side proxy 
     âœ” Anonymity of servers
     âœ” disguises a servers IP addresses
     âœ” used for traffic control caching the response from servers
     âœ” Load balancing => distributes the load for app using multiple servers
     âœ” Provides a single configuration point to manage SSL/technologies
     âœ” Mitigate the DDoS attacks=> deflates overall impact of distributed denial of services attacks.
     âœ” Example: VPN, Dark web
     âœ” Can be use to bypass the blocked websites
     âœ” Sometimes bottleneck problem might occur

ğŸ’¾ Part 5
ğŸ’» Data & Data Flow
    ğŸ“¢ Data    
    ğŸ“¢ Data format/representation    
    ğŸ“¢ Mechanisms for Data flow    
    ğŸ“¢ Factors => Type, volume, scale, purpose    

    ğŸ“¢ Layers
       âœ” Business Layer => text, images, vides, notes ... 
       âœ” Application Layer => JSON/XML
       âœ” Data stores => databases- tables, indexes, lists, trees
       âœ” Network Layer => Packets  
       âœ” Hardware Layer => 0's & 1's

"Always think about data flow"

    ğŸ“¢ Data storesğŸ–¥
      âœ” Databases => Username, phone ...
      âœ” Queues => [Send sms request, send email request]
      âœ” Caches => [Request:Response] 
      âœ” Indexes => [Most searched items, items searched in last 1 hour]

    ğŸ“¢ Data flow methods <=>
      âœ” APIs  
      âœ” Messages  
      âœ” Events  

    ğŸ“¢ Data generation 
      âœ” Users => Input
      âœ” Internal => system populated 
      âœ” Insights => when user upload or retrieve some data 
        Example: if a user buys, invoice generation
                youtube history, payment details, profile details,...

    ğŸ“¢ Factors
      âœ” Type of data => knowing the type of data is important, images or videos ...  
      âœ” Volume  => system supporting gb or tb
      âœ” Consumption / Retrieval => reads /writes
      âœ” security => transaction, banking

    ğŸ“¢ Types of system
    Examples
      âœ” Authorization system => User login, ID management
      âœ” Streaming system => Netflix, Hotstar, Prime video, ...
      âœ” Transactional system => Ecommerce, booking rides, grocery, ...
      âœ” Heavy compute system => image recognition, video processing, using ML models

ğŸ’¾ Part 6
ğŸ’» Databases
    ğŸ“¢ Types of Databases    
    ğŸ“¢ Pros & Cons 
    ğŸ“¢ Use Cases   
    ğŸ“¢ Examples

    ğŸ“¢ Types of Databases   
      âœ” Relational
        - Schema => Tables & Rows
                => Primary key, not null, foreign key, int, varchar, default, etc. are all example of schema constraints
            Example:
            Table1: Employees => ID[Primary key], Name, age,dept_id[Foreign key,NOT NULL],acc_id [Foreign key, NOT NULL] 
            Table1: Department => ID[Primary key], Name, start_date, HOD
            Table1: Account => ID[Primary key], debit, credit, balance, is_employee
        => database for inter related complex data can be easily designed
        => ensures garbage or null value is not populated
        => ensures all other schema constraints are followed

        - ACID Properties => 
            => Atomicity: Either All or none
            => Consistency: Same value for both the request
            => Isolation: Read and writes are isolated
            => Durability: Mechanism to guarantee that transactions completed will survive permanently

        - Schema change is difficult to evolve
        - difficult for horizontal scaling

      âœ” Non-relational => AKA NoSQL Databases
      - No fixed schemas
      - Does not follow ACID Properties
      - different types of relational databases are used for different purposes

      âœ” Key value stores => Application or configuration data
                        => caching data
            example: feature, discount, enable cities,...

      âœ” Document based Databases
      - No fixed schema, supports heavy reads and writes
      - collections(tables) => documents(rows)
      - flexible complex dynamic data
      - highly scalable
      - sharding
      - special query operations/aggregations
      - saved in JSON format
        example: 
        [
            {
                id:"1",
                name: "jack",
                city: 
                {
                    id:"2",
                    name:"la",
                    state:"california"
                },
                country:
                {
                    id:"4",
                    Name:"usa",
                    code:"US",
                    continent:"North America"
                }
            }

        ]

      âœ” column based Databases
      - supports large number of heavy writes, special reads
      - distributed
      - Example: event data, or streaming data, storing data for songs
            Cassandra, HBase, Sylla
     
      âœ” Search Databases
      - Supports Full text search queries
      - Images/Videos, Amazon s3, buckets
      - Large datasets
      - Time series
      - Example: Elastic, Solar, ...

ğŸ’¾ Part 7
ğŸ“¢ Anatomy of Applications & services
ğŸ’» Client <=> ğŸ’» Servers
  âœ” Application in both client and server side have different responsibilities
  Tech stack
  âœ” The applications are language agnostic for interacting with each other

  Client Apps => rendering UI elements
              => handle interactions
              => collect data
              => communicate with backend via APIs to fetch/store data
              => render static data/info
  Server Apps => Expose API endpoints
              => house business Logic
              => handling data modeling/transform
              => interact with data stores
              => interact with other services           
ğŸ’» Elements/factors of app design/development
              => requirements - gather requirements
              => layer - web/mobile/desktop/backend app
              => tech stack - which language to use
              => code structures / design pattern
              => data store interactions
              => performance cost
              => deployment
              => monitoring
              => operations excellence /reliability

ğŸ’¾ Part 8
ğŸ’» Application Programming Interface (API)
ğŸ“¢ What is API?
    âœ” one piece of code interacting with another which can run on different machine.
    âœ” Advantages => communication 
                => Abstraction
                => platform agnostic

ğŸ“¢ Examples and usecases
ğŸ“¢ Types of APIs

    âœ” Private APIs => hidden APIs
    âœ” Public APIs => available for Public,
    âœ” web APIs => superset of private & public, get,post...
    âœ” SDK/library => lock,fork, join, release lock

ğŸ“¢ API Factors => API contracts
                => Documentation
                => Data format
                => security

ğŸ“¢ API Standards => RPC
                => SOAP
                => REST

ğŸ’¾ Part 9 
ğŸ’» Cache
  ğŸ“¢ What is Cache?
      âœ” a hardware or a software component which helps in serving the data which is frequently requested or expensive to compute on, so cache saves this request.
      âœ” cache example => server side cache (reverse proxy)
              => browser cache (client side)
              => similar redundant request and response is saved in cache memory

  ğŸ“¢ invalidation and eviction  
     âœ” Cache invalidation => data should be changed in some time, updating old value with a new value in cache is cache invalidation
         => TTL - Time to live (expiry date for the cache)
     âœ” Cache eviction - when old cache has to be evicted for new keys
                      => FIFO - first in first out (first inserted is evicted)
                      => LRU - Least recently used (oldest is evicted)
                      => LFU - Least frequently used (less times used evicted)
  
  ğŸ“¢ Cache pattern
    âœ” Cache aside strategy/Patterns -application communication with cache doesnot communicate with Database
                      => Advantage - when cache fails, application can still serve using database
                      => supports heavy reads
                      => works even if cache is down
                      => TTL/application code have to be used keep DB and cache consistent

                      => disadvantage - to decide about cache long expiry or application code to refresh cache


    âœ” Cache read through strategy/pattern - cache sits between application & database
                                           - application only communicates with cache
                       => Advantage - read heavy work 
                       => great alternate for read heavy workloads, example: newsfeed
                       => data modeling of cache and db has to be smaller
      
                        => disadvantage - first request always miss cache. (can be solved by preloading the cache)
  
    âœ” Cache write through strategy/pattern - similar to read through, application will read & write in cache.           => Advantage - can directly write to cache
                        => disadvantage - extra layer of latency of reading from cache (can be solved using write around pattern)
    
    âœ” Cache write around strategy/pattern- writes directly to db but reads from cache

    âœ” Cache write back strategy/pattern- writes is saved in cache and writing in db later in bulk
                        => Advantage - useful for write heavy workloads
                                    - db failure can be sustained for the time cache keeps data in bulk
                                    - used by various DB's internal implementation
                                    - cache failure results in system failure

  ğŸ“¢ Where is my cache?
      => can be in client browser
      => can be in forward proxy
      => can be in reverse proxy
      => can be in application 
      => can be outside database

ğŸ’¾ Part 10     
ğŸ’» REST APIs
    ğŸ“¢ What is REST?
        âœ” Representational State Transfer
        âœ” how data is exchanged between client and server 
        âœ” Follows 6 guidelines 
        âœ” Architecture Style for Web API from the thesis of Roy Fielding
        âœ” Uses XML or JSON to send & receive the data
        âœ” simply calls services via URL path
        âœ” result is readable which is just plain XML or JSON
        âœ” Transfer is over HTTP only
        âœ” Easy to call from JavaScript
        âœ” performance much better than SOAP, less CPU intensive, leaner code, etc.
        âœ” Resources => URI, Uniform Interface - Methods, Representational 
        âœ” Protocol => Client-server, 
                    => stateless - one server gets multiple request from same or different clients
                    => cacheable
                    => layered
                    => Uniform interface
                    => code on demand(optional)- a server can send code to client that it should execute in runtime(like Java Applets or JavaScript)
        âœ” Hypermedia as the Engine of application state. (HATEOAS)
       Advantages - Efficiency
                  - scalable
                  - User perceived performance
           
           
    ğŸ“¢ HTTP methods - GET => retrieve data from a specified Resource
                       POST => submit data to be processed to a specific Resources
                       PUT => update a specified Resource
                       DELETE => delete a specified Resource
                       HEAD => same as get but does not return a body
                       OPTIONs=> returns the supported HTTP methods
                       PATCH => Update partial Resources

    ğŸ“¢ End points - URI/URL where api/services can be accessed by a client app
                  - Get => https://mysite.com/api/users
                  - Get => https://mysite.com/api/users/1 or users/details/1
                  - Post => https://mysite.com/api/users
                  - Put => https://mysite.com/api/users/1 or users/update/1
                  - delete => https://mysite.com/api/users/1 or user/delete/1                    

    ğŸ“¢ State transfer & stateless
        âœ” State transfer - state of data that is being transferred from server to client
        âœ” Stateless - multiple clients requesting for one server, server is unknown to the state of the client request, hence stateless.

    ğŸ“¢ Path vs Query params
        âœ” Path params - specific resource via path using id in the URI
        âœ” Query params - specific resource using query in the URI
    
    ğŸ“¢ HTTP status codes
        âœ” 1xx => informal error
        âœ” 2xx => success 
        âœ” 3xx => redirection
        âœ” 4xx => client error 
        âœ” 5xx => server error

    ğŸ“¢ Security, Authorization & Error handling 


    ğŸ“¢ Difference in SOAP and REST
        âœ” Analogy => SOAP is like envelope & REST is like postcard. SOAP being more secure
        âœ” SOAP => XML based message protocol
              => uses WSDL for communication between consumer & provider
              => invokes services by calling RPC
              => does not return human readable results
              => transfer is over HTTP, Also uses other protocol such as SMTP, FTP,etc.
              => JavaScript can call SOAP, but difficult to implementation
              => performance not great compare to REST
     
    ğŸ“¢ API Gateway
        âœ” component acts as an entry point for APIs
        âœ” Security
        âœ” Authenticated
        âœ” Authorization
        âœ” SSL termination
        âœ” DDoS protection/ Throttling
        
        Features
        âœ” Separate cross cutting concerns 
        âœ” Separate and consolidate cross cutting concerns across microservices
        âœ” Replacing multiple clients calls with single API call 
        âœ” Reverse proxy: serving static content; caching responses
        âœ” Routing based on headers, paths & params,etc. 
        âœ” Load balancing, A/B testing, Canary releases

        Self managed
        âœ” Apache
        âœ” HAProxy
        âœ” NGINX
        âœ” Spring Cloud Gateway

        Cloud services
        âœ” AWS API Gateway
        âœ” Azure API Gateway
        âœ” Google Cloud endpoints
        âœ” Apigee
      
ğŸ’¾ Part 11     
ğŸ’» Message Queues
    ğŸ“¢ Sync & Async
       ğŸ“¢ Synchronous communication => Information/data is shared in real time
                No wait, direct & immediate communication, analogy-phone communication

       ğŸ“¢ asynchronous communication => Information/data is independent of time, 
                Wait for response, analogy - email, chat, etc. immediate response not necessary
            âœ” Real time analogy 1 => customers waiting in the bank, either queue or token system
                                    - Larger number of customer served though delay
            âœ” Online store => when ordered the store says successfully order placed.
                            => larger number of customers requesting for invoice history will be queued
                            => the invoice will be sent to their specific email

    ğŸ“¢ What is Message Queues?
        âœ” are middleware used by different parts of the system (producers/consumers) to communicate or process operations asynchronously
        âœ” process which has data structure in the memory to store the messages
        âœ” could be process running in the same machine or different interacting with each other
        âœ” E.g. - Kafka, SQS, RabbitMQ

    ğŸ“¢ Models: Producer & Consumer
        âœ” Producer => add messages to the queue which has to be processed
        âœ” Consumer => carries out the message and start operation

        order=> FIFO - Amazon SQS- the next message cannot be consumed until it processed the first one
                => downside is it stops processing if one of the processing fails 

                => ordered MQs (e.g. text messages)
                => unordered MQs (eg. invoice generation request)
        consumption => one to one - Producer consumer model
                    =>One to many - Publish subscriber model

    ğŸ“¢ Advantages & disadvantage
        âœ” producers can help when all the load can be enqueued & decoupling
        âœ” when there is load consumers rate can be increased & dequeued
        âœ” sending emails, decoupling 
        âœ” bulk operations can be handled
        
        
ğŸ’¾ Part 12     
ğŸ’» Pub-sub Messaging => Analogy - Broadcast message
                    => Publisher => Similar to producer, publishes the message via input channel
                    => subscriber => similar to consumer, consumers or reacts to the messages via output channel
                    => Message broker => modifies data to the outpur channel, 
                                     => divides the messages to rdifferent responsible subscribers
                
                Example: Analogy of Ecommerce site
                    => Order placed can be published using publisher
                    => Order Id messages sent to input channel
                    => Message broker fetches details from Order Id and sends to the output channel
                    => SMS, Email, Logs, Order processing are the subscribers 
                    => based on the published data, the subscribers reacts based on their responsibilities


                Factors => Message Ordering
                        => Message consumption
                        => Posion Messages
                        => Duplicate Messages

    Usecases => Async workflow - adding to cart is sync workflow but process after added to cart can be async workflow
             => decoupling - continuous UI clicks or events can be in a queue
             => load balancing - balancing heavy throughput, by adding subscribers for a multiple events from publishers
             => deferred processing - according to the scheduled time the events are processed
             => data streaming 

            When to not to use => limited number of orders not required to use this pattern
                               => for real time systems
                            